#Standard Built-Ins

Below are the standard built-in predicates of Brachylog. All of them have one Input and one Output, denoted respectively by `?` and `.` in each of the predicate's description.

|Symbol|Name|                                        Description|
|:----:|:--------------:|:----------------------------------------------------------------------------------------
| `a`    | Apply | Applies the last element of `?` (i.e. a predicate name) to each element of `?` but the last. If `?` contains only one element beside the predicate name, and it is a list, it will apply on each element of this list. `.` will be unified with the list of the outputs of the application of the predicate to each element.
| `b`    | Behead | <ul><li>On lists: unifies `.` with `?` minus its first element</li><li>On strings: unifies `.` with `?` minus the first character</li><li>On numbers: unifies `.` with `?` minus its first digit</li></ul>
| `c`    | Concatenate | Unifies `.` with the concatenation of all elements of `?`. All elements must be of the same type. Works on lists of strings/integers/lists.
| `d`    | Duplicates | Unifies `.` with `?` where only the first occurence of each element is kept. Works on lists, strings, numbers.
| `e`    | Enumerate | <ul><li>`?` is a string: unifies `.` with a character of `?`. Backtracking on this predicate will produce each character of `?` from left to right</li><li>`?` is an integer: unifies `.` with a digit of `?`. Backtracking on this predicate will produce each digit of `?` from left to right</li><li>`?` is a list: unifies `.` with an element of `?`. Backtracking on this predicate will produce each element of `?` from left to right</li></ul>
| `f`    | Findall | `? = [Arg1:...:ArgN:PredName]. `Unifies `.` with a list of all possible variable bindings which satisfy a predicate `P` with this binding as output. `?`.
| `g`    | Group | Unifies `.` with `[?]`
| `h`    | Head | <ul><li>On lists: unifies `.` with the first element of `?`</li><li>On strings: unifies `.` with the first character of `?`</li><li>On numbers: unifies `.` with the first digit of `?`</li></ul>
| `i`    | Iterate | `? = [Arg1:...:ArgN:I:Pred]`. Calls `Pred` with `[Arg1:...:ArgN]` as input. Then, calls `Pred` with the output of the previous call as input, etc. This is done `I` times, after which `.` is unified with the output of the last call of `Pred`.
| `j`    | Juxtapose | `? = [A:I]`. Unifies `.` with `A` concatenated `I` times to itself.
| `k`    | Knife | <ul><li>On lists: unifies `.` with `?` minus its last element</li><li>On strings: unifies `.` with `?` minus the last character</li><li>On numbers: unifies `.` with `?` minus its last digit</li></ul>
| `l`    | Length | Unifies `.` with the length of `?` (number of elements / number of characters / number of digits).
| `m`    | Member | `? = [A:I]`. Unify `.` with the `I`th element of `A`.
| `n`    |  | 
| `o`    | Order | Unifies `.` with `?` sorted in ascending order, according to the standard order of terms in Prolog. If the last element of `?` is a predicate name (either directly a built-in or using `{…}`), then the list is sorted in ascending order based on the output of that predicate for each element of `?` minus the predicate name.
| `p`    | Permute | Unifies `.` with a permutation of `?` (elements / characters / digits). Backtracking on this predicate will produce each possible permutation exactly once
| `q`    |  | 
| `r`    | Reverse | Unifies `.` with the reverse of `?`
| `s`    | Subset | Unifies `.` with a subset of `?` (elements / characters / digits). Only the subsets that have the same ordering as `?` are valid. Backtracking on this predicate will produce each one of those subsets exactly once
| `t`    | Tail | <ul><li>On lists: unifies `.` with the last element of `?`</li><li>On strings: unifies `.` with the last character of `?`</li><li>On numbers: unifies `.` with the last digit of `?`</li></ul>
| `u`    |  | 
| `v`    | Void | True if `?` is either `[]`, `""`, `0` or `0.0`. `.` is an anonymous variable which will unify with anything.
| `w`    | Write | Write `?` to `STDOUT`. If `?` has more than one element and the last one is a string, then this string is used to format the rest of the input (See [`format/2`](http://www.swi-prolog.org/pldoc/doc_for?object=format/2))
| `x`    | Xterminate | `? = [X:Y]`. `.` is `X` with `Y` removed (e.g. `"test":"te"x` gives `"st"`). If `Y` is a list, removes all elements of `Y` from `X`. **Note: this is not implemented for numbers yet**.
| `y`    | Yield | <ul><li>On integers: unifies `.` with the list of all integers between `0` and `?`</li><li>`? = ["I":"J"]`, where I and J are any character. Unifies `.` with all 1-length strings of characters between `I` and `J` (based on character codes).</li><li>`? = [Arg1:...:ArgN:I:Pred]`. Unify `.` with the first `I` solutions of `Pred` given `[Arg1:...:ArgN]` as input.</li></ul>
| `z`    | Zip | `.` is a list of lists where the `I`th sublist contains the `I`th elements of each element of `?`. This will wrap around for elements of `?` which are shorter in length than the longest element of `?`. 
| `&`    | Call Predicate | Calls the `I`th predicate with `[Arg1:...:ArgN]` as input, assuming that `? = [Arg1:...:ArgN:I]`. If the last element of `?` is not an integer, then the current predicate is recursively called. `.` Is unified with the output of that predicate call.
| `+`    | Plus | <ul><li>On one number: unifies `.` with `? + 1` (or adds a constraint if it's an integer)</li><li>On integers: applies the constraint `. = A + B + ...`, where `? = [A:B:...]`</li><li>When one float is involved: does normal summing without constraints. Labelizes integers if needed</li></ul>
| `-`    | Minus | <ul><li>On one number: unifies `.` with `? - 1` (or adds a constraint if it's an integer)</li><li>On integers: applies the constraint `. = A - B`, where `? = [A:B]`</li><li>When one float is involved: does normal subtraction without constraints. Labelizes integers if needed</li></ul>
| `*`    | Multiply | <ul><li>On one number: unifies `.` with `2×?` (or adds a constraint if it's an integer)</li><li>On integers: applies the constraint `. = A * B * ...`, where `? = [A:B:...]`</li><li>When one float is involved: does normal multiplication without constraints. Labelizes integers if needed</li></ul>
| `/`    | Divide | <ul><li>On one number: unifies `.` with the inverse of `?`</li><li>On integers: applies the constraint `. = A // B`, where `? = [A:B]`</li><li>When one float is involved: does normal division without constraints. Labelizes integers if needed</li></ul>
| `^`    | Power | <ul><li>On one number: unifies `.` with the square of `?` (or adds a constraint if it's an integer)</li><li>On integers: applies the constraint `. = A ^ B`, where `? = [A:B]`</li><li>When one float is involved: does normal powering without constraints. Labelizes integers if needed</li></ul>
| `%`    | Modulus | Unifies `.` with `A mod B` where `? = [A:B]`. Only works on integers.
| `=`    | Equal | Labelizes `?` or the elements of `?` if it's a list. Unifies `.` with `?`.
| `<`    | Less | True if `? < .`. For integers, it adds a constraint. When one is an integer an the other is a float, this will labelize the integer.
| `>`    | Greater | True if `? > .`. For integers, it adds a constraint. When one is an integer an the other is a float, this will labelize the integer.
| `<=`   | Less-equal | True if `? <= .`. For integers, it adds a constraint. When one is an integer an the other is a float, this will labelize the integer.
| `>=`   | Greater-equal | True if `? >= .`. For integers, it adds a constraint. When one is an integer an the other is a float, this will labelize the integer.


